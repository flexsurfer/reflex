## 0) Reflex Quick Info

- Reflex is a React state-management library inspired by ClojureScript re-frame (event-driven updates, subscriptions for derived data, effects/coeffects for side effects).
- Install:
  - Runtime: `npm i @flexsurfer/reflex`
  - Devtools (dev only): `npm i -D @flexsurfer/reflex-devtools`
- Docs:
  - Main docs: [reflex.js.org/docs](https://reflex.js.org/docs)
  - Best practices: [reflex.js.org/docs/best-practices.html](https://reflex.js.org/docs/best-practices.html)
  - Packages: [@flexsurfer/reflex](https://www.npmjs.com/package/@flexsurfer/reflex), [@flexsurfer/reflex-devtools](https://www.npmjs.com/package/@flexsurfer/reflex-devtools)

## 1) State Architecture

Use this baseline structure:

```text
src/state/
  db.ts
  event-ids.ts
  events.ts
  effect-ids.ts
  effects.ts
  sub-ids.ts
  subs.ts
```

Rules:
- Keep IDs centralized in `event-ids.ts`, `effect-ids.ts`, `sub-ids.ts`.
- Keep init in `db.ts` (`initAppDb(...)`).
- Register events/effects/subscriptions via side-effect imports in app bootstrap (`main.tsx` style).
- If `events.ts` or `subs.ts` grows too large, split by feature, keep shared/global state separate.

## 2) State Shape

- Grow horizontally (new top-level feature keys), avoid deep nesting.
- Normalize entity-like data (`byId` maps + id arrays) for fast lookup and simpler updates.
- Keep UI state explicit and separate from domain entities.
- If using `Map`/`Set` in DB, call `enableMapSet()` before `initAppDb`.

## 3) Events `regEvent`

- Events must be synchronous and focused on state transitions.
- Events should read all required data from `draftDb` (or via coeffects) — never rely on callers passing subscription-derived state; dispatch calls from views should only carry user intent (IDs, input values, flags).
- Validate inputs and guard clauses first; return early on invalid state.
- Mutate only required fields on `draftDb`.
- Avoid unnecessary object/array recreation (`{...obj}`, `[...arr]`) when no actual change is needed.
- Never perform async/API/localStorage work directly in events.
- Return effect tuples for side effects.
- When sending mutated draft data to effects, always use `current(...)`.
- Prefer deterministic coeffects (time/id/random/env) instead of direct globals for testability.

Event naming:
- Keep exported constant keys in `UPPER_SNAKE_CASE`.
- Use namespaced string values: `feature/action` (example: `bases/create`).
- Keep key and value aligned:
  - `BASES_CREATE` -> `bases/create`
  - `PRODUCTION_PLAN_ADD_BUILDINGS_TO_BASE` -> `production_plan/add_buildings_to_base`

## 4) Effects and Coeffects

- Put all I/O here: localStorage, HTTP, timers, analytics, navigation.
- Effects should be small, defensive, and fail-soft (log, do not crash app state flow).

## 5) Subscriptions `regSub`

- Define root subscriptions first `regSub(id, "pathKey")`.
- Build derived subscriptions from other subscriptions only.
- Use parameterized subscriptions for by-id and section-specific queries.
- Keep subscriptions deterministic and lightweight.
- Subscriptions must return data shaped and ready for direct view consumption — all filtering, sorting, formatting, and joining should happen in the subscription layer, not in React components.
- Move heavy computations to events (precompute once, read many); avoid repeated expensive derivations in hot subscriptions.

## 6) React Component Contract

- Components should only:
  - subscribe to minimal required data
  - dispatch events on user intent (pass only user-provided values — e.g. input text, selected id — never forward subscription data back through dispatch; the event handler should read everything it needs from the DB itself)
  - render UI
- Never transform, filter, sort, or reshape subscription data inside a component — if the view needs a different shape, create a dedicated subscription that returns it ready to render.
- Use direct React hooks only for local/ephemeral component concerns:
  - temporary form/input draft state before dispatch
  - UI-only toggles scoped to one component (hover/open/focus)
  - refs, DOM measurement, animation lifecycle
- Do not mirror Reflex global state in `useState`/`useReducer`.
- If state is shared, persisted, or business-relevant, keep it in Reflex DB via events/subscriptions.
- Keep `useEffect` thin in components; business side effects belong in Reflex effects/coeffects.
- Do not place business rules/validation pipelines in component handlers.
- Avoid over-subscription (row/item components should not subscribe to full collections).

## 7) Test Minimum

For every new feature:
- Event tests: mutation correctness + emitted effect tuples.
- Subscription tests: derived outputs from fixed state fixtures.

## 8) AI Generation Checklist

Before finalizing generated code:
- IDs added/updated in all relevant `*-ids.ts` files.
- Event namespaced and descriptive.
- Side effects isolated to effects/coeffects.
- `current(...)` used when passing draft-derived data to effects.
- No unnecessary object/array recreation in events.
- Expensive work not placed in frequently re-run subscriptions.
- Subscriptions return view-ready data; components do not reshape subscription output.
- Dispatch calls from components pass only user intent, not subscription data; events read from DB.
- Tests added for new event/subscription behavior.

## 9) Starter Skeleton (copy pattern)

```ts
import {
  initAppDb,
  regSub,
  regEvent,
  regEffect,
  regCoeffect,
  current,
  dispatch,
  useSubscription,
} from '@flexsurfer/reflex';

// event-ids.ts
export const EVENT_IDS = {
  APP_INIT: 'app/init',
  TODOS_ADD: 'todos/add',
} as const;

// effect-ids.ts
export const EFFECT_IDS = {
  GET_TODOS: 'storage/get_todos',
  SET_TODOS: 'storage/set_todos',
} as const;

// sub-ids.ts
export const SUB_IDS = {
  TODOS_LIST: 'todos/list',       // root sub
  TODOS_OPEN_COUNT: 'todos/open_count', // computed sub
} as const;

// db.ts
type Todo = { id: string; text: string; done: boolean };
initAppDb({ todos: [] as Todo[] });

// effects.ts
regEffect(EFFECT_IDS.SET_TODOS, (todos: Todo[]) => {
  localStorage.setItem('todos', JSON.stringify(todos));
});

regCoeffect(EFFECT_IDS.GET_TODOS, (coeffects) => {
  const raw = localStorage.getItem('todos');
  coeffects.localStoreTodos = raw ? (JSON.parse(raw) as Todo[]) : [];
  return coeffects;
});

// events.ts
regEvent(
  EVENT_IDS.APP_INIT,
  ({ draftDb, localStoreTodos }) => {
    draftDb.todos = Array.isArray(localStoreTodos) ? localStoreTodos : [];
  },
  [[EFFECT_IDS.GET_TODOS]]
);

regEvent(EVENT_IDS.TODOS_ADD, ({ draftDb }, text: string) => {
  const clean = text.trim();
  if (!clean) return;
  draftDb.todos.push({ id: `todo_${Date.now()}`, text: clean, done: false });
  return [[EFFECT_IDS.SET_TODOS, current(draftDb.todos)]];
});

// subs.ts
regSub(SUB_IDS.TODOS_LIST, 'todos'); // root sub

regSub(
  SUB_IDS.TODOS_OPEN_COUNT,          // computed sub from root sub
  (todos: Todo[]) => todos.filter((t) => !t.done).length,
  () => [[SUB_IDS.TODOS_LIST]]
);

// Usage example (React):
// const todos = useSubscription([SUB_IDS.TODOS_LIST]);
// const openCount = useSubscription([SUB_IDS.TODOS_OPEN_COUNT]);
// dispatch([EVENT_IDS.APP_INIT]);
// dispatch([EVENT_IDS.TODOS_ADD, 'Buy milk']);
```